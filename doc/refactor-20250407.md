# Guide de Refactoring - 2025-04-07

## Objectif

Éliminer le code dupliqué dans l'application pour améliorer la maintenabilité, la stabilité et la cohérence du code.

## Problèmes identifiés

1. Duplication dans les contrôleurs REST (CRUD)
2. Duplication dans les services (délégation aux cas d'utilisation)
3. Duplication dans les cas d'utilisation (validation et gestion des erreurs)
4. Duplication dans les filtres et aspects (utilitaires HTTP)
5. Duplication dans les repositories (méthodes de requête)

## Solutions à implémenter

### 1. Contrôleurs génériques

```java
package com.devolution.saas.common.api;

import com.devolution.saas.common.annotation.Auditable;
import io.swagger.v3.oas.annotations.Operation;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Contrôleur générique pour les opérations CRUD.
 *
 * @param <T> Type de l'entité DTO
 * @param <ID> Type de l'identifiant
 * @param <C> Type de la commande de création
 * @param <U> Type de la commande de mise à jour
 */
@Slf4j
public abstract class AbstractCrudController<T, ID, C, U> {

    /**
     * Crée une nouvelle entité.
     *
     * @param command Commande de création
     * @return Entité créée
     */
    protected abstract T create(C command);

    /**
     * Met à jour une entité existante.
     *
     * @param id ID de l'entité
     * @param command Commande de mise à jour
     * @return Entité mise à jour
     */
    protected abstract T update(ID id, U command);

    /**
     * Récupère une entité par son ID.
     *
     * @param id ID de l'entité
     * @return Entité récupérée
     */
    protected abstract T get(ID id);

    /**
     * Liste toutes les entités.
     *
     * @return Liste des entités
     */
    protected abstract List<T> list();

    /**
     * Supprime une entité.
     *
     * @param id ID de l'entité
     */
    protected abstract void delete(ID id);

    /**
     * Retourne le nom de l'entité pour les logs.
     *
     * @return Nom de l'entité
     */
    protected abstract String getEntityName();

    /**
     * Endpoint pour créer une nouvelle entité.
     *
     * @param command Commande de création
     * @return Réponse HTTP avec l'entité créée
     */
    @PostMapping
    @Operation(summary = "Crée un nouvel élément")
    @Auditable(action = "API_CREATE")
    public ResponseEntity<T> createEntity(@Valid @RequestBody C command) {
        log.debug("REST request pour créer un {}: {}", getEntityName(), command);
        T result = create(command);
        return ResponseEntity.status(HttpStatus.CREATED).body(result);
    }

    /**
     * Endpoint pour mettre à jour une entité existante.
     *
     * @param id ID de l'entité
     * @param command Commande de mise à jour
     * @return Réponse HTTP avec l'entité mise à jour
     */
    @PutMapping("/{id}")
    @Operation(summary = "Met à jour un élément existant")
    @Auditable(action = "API_UPDATE")
    public ResponseEntity<T> updateEntity(@PathVariable ID id, @Valid @RequestBody U command) {
        log.debug("REST request pour mettre à jour le {}: {}", getEntityName(), command);

        if (!isValidId(id, command)) {
            return ResponseEntity.badRequest().build();
        }

        T result = update(id, command);
        return ResponseEntity.ok(result);
    }

    /**
     * Endpoint pour récupérer une entité par son ID.
     *
     * @param id ID de l'entité
     * @return Réponse HTTP avec l'entité récupérée
     */
    @GetMapping("/{id}")
    @Operation(summary = "Récupère un élément par son ID")
    @Auditable(action = "API_GET")
    public ResponseEntity<T> getEntity(@PathVariable ID id) {
        log.debug("REST request pour récupérer le {}: {}", getEntityName(), id);
        T result = get(id);
        return ResponseEntity.ok(result);
    }

    /**
     * Endpoint pour lister toutes les entités.
     *
     * @return Réponse HTTP avec la liste des entités
     */
    @GetMapping
    @Operation(summary = "Liste tous les éléments")
    @Auditable(action = "API_LIST")
    public ResponseEntity<List<T>> listEntities() {
        log.debug("REST request pour lister les {}", getEntityName());
        List<T> result = list();
        return ResponseEntity.ok(result);
    }

    /**
     * Endpoint pour supprimer une entité.
     *
     * @param id ID de l'entité
     * @return Réponse HTTP vide
     */
    @DeleteMapping("/{id}")
    @Operation(summary = "Supprime un élément")
    @Auditable(action = "API_DELETE")
    public ResponseEntity<Void> deleteEntity(@PathVariable ID id) {
        log.debug("REST request pour supprimer le {}: {}", getEntityName(), id);
        delete(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * Vérifie si l'ID dans l'URL correspond à l'ID dans la commande.
     * À surcharger dans les classes concrètes si nécessaire.
     *
     * @param id ID dans l'URL
     * @param command Commande de mise à jour
     * @return true si l'ID est valide, false sinon
     */
    protected boolean isValidId(ID id, U command) {
        return true;
    }
}
```

### 2. Services génériques

```java
package com.devolution.saas.common.application.service;

import com.devolution.saas.common.annotation.Auditable;
import com.devolution.saas.common.annotation.TenantRequired;
import lombok.extern.slf4j.Slf4j;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * Service générique pour les opérations CRUD.
 *
 * @param <T> Type de l'entité DTO
 * @param <ID> Type de l'identifiant
 * @param <C> Type de la commande de création
 * @param <U> Type de la commande de mise à jour
 */
@Slf4j
public abstract class AbstractCrudService<T, ID, C, U> {

    /**
     * Exécute la création d'une entité.
     *
     * @param command Commande de création
     * @return Entité créée
     */
    protected abstract T executeCreate(C command);

    /**
     * Exécute la mise à jour d'une entité.
     *
     * @param command Commande de mise à jour
     * @return Entité mise à jour
     */
    protected abstract T executeUpdate(U command);

    /**
     * Exécute la récupération d'une entité.
     *
     * @param id ID de l'entité
     * @return Entité récupérée
     */
    protected abstract T executeGet(ID id);

    /**
     * Exécute la liste des entités.
     *
     * @return Liste des entités
     */
    protected abstract List<T> executeList();

    /**
     * Exécute la suppression d'une entité.
     *
     * @param id ID de l'entité
     */
    protected abstract void executeDelete(ID id);

    /**
     * Retourne le nom de l'entité pour les logs.
     *
     * @return Nom de l'entité
     */
    protected abstract String getEntityName();

    /**
     * Crée une nouvelle entité.
     *
     * @param command Commande de création
     * @return Entité créée
     */
    @Transactional
    @Auditable(action = "CREATE")
    @TenantRequired
    public T create(C command) {
        log.debug("Création d'un nouveau {}: {}", getEntityName(), command);
        return executeCreate(command);
    }

    /**
     * Met à jour une entité existante.
     *
     * @param command Commande de mise à jour
     * @return Entité mise à jour
     */
    @Transactional
    @Auditable(action = "UPDATE")
    @TenantRequired
    public T update(U command) {
        log.debug("Mise à jour du {}: {}", getEntityName(), command);
        return executeUpdate(command);
    }

    /**
     * Récupère une entité par son ID.
     *
     * @param id ID de l'entité
     * @return Entité récupérée
     */
    @Transactional(readOnly = true)
    @Auditable(action = "GET")
    public T get(ID id) {
        log.debug("Récupération du {}: {}", getEntityName(), id);
        return executeGet(id);
    }

    /**
     * Liste toutes les entités.
     *
     * @return Liste des entités
     */
    @Transactional(readOnly = true)
    @Auditable(action = "LIST")
    public List<T> list() {
        log.debug("Listage des {}", getEntityName());
        return executeList();
    }

    /**
     * Supprime une entité.
     *
     * @param id ID de l'entité
     */
    @Transactional
    @Auditable(action = "DELETE")
    @TenantRequired
    public void delete(ID id) {
        log.debug("Suppression du {}: {}", getEntityName(), id);
        executeDelete(id);
    }
}
```

### 3. Cas d'utilisation génériques

```java
package com.devolution.saas.common.application.usecase;

import com.devolution.saas.common.domain.exception.BusinessException;
import com.devolution.saas.common.domain.exception.ResourceNotFoundException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

/**
 * Cas d'utilisation générique pour la création d'entités.
 *
 * @param <T> Type de l'entité DTO
 * @param <C> Type de la commande de création
 * @param <E> Type de l'entité de domaine
 */
@Slf4j
public abstract class AbstractCreateUseCase<T, C, E> {

    /**
     * Crée une entité à partir d'une commande.
     *
     * @param command Commande de création
     * @return Entité créée
     */
    protected abstract E createEntity(C command);

    /**
     * Convertit une entité de domaine en DTO.
     *
     * @param entity Entité de domaine
     * @return DTO
     */
    protected abstract T toDto(E entity);

    /**
     * Vérifie si une entité existe déjà avec les critères d'unicité.
     *
     * @param command Commande de création
     * @return true si une entité existe déjà, false sinon
     */
    protected abstract boolean existsByUniqueCriteria(C command);

    /**
     * Retourne le nom de l'entité pour les messages d'erreur.
     *
     * @return Nom de l'entité
     */
    protected abstract String getEntityName();

    /**
     * Retourne le nom du champ unique pour les messages d'erreur.
     *
     * @return Nom du champ unique
     */
    protected abstract String getUniqueFieldName();

    /**
     * Exécute le cas d'utilisation.
     *
     * @param command Commande de création
     * @return DTO de l'entité créée
     */
    @Transactional
    public T execute(C command) {
        log.debug("Exécution du cas d'utilisation de création de {}", getEntityName());

        // Vérification de l'unicité
        if (existsByUniqueCriteria(command)) {
            throw new BusinessException(
                    getEntityName() + "." + getUniqueFieldName() + ".duplicate",
                    "Un " + getEntityName() + " avec ce " + getUniqueFieldName() + " existe déjà"
            );
        }

        // Création de l'entité
        E entity = createEntity(command);

        // Conversion en DTO
        return toDto(entity);
    }
}

/**
 * Cas d'utilisation générique pour la mise à jour d'entités.
 *
 * @param <T> Type de l'entité DTO
 * @param <U> Type de la commande de mise à jour
 * @param <E> Type de l'entité de domaine
 * @param <ID> Type de l'identifiant
 */
@Slf4j
public abstract class AbstractUpdateUseCase<T, U, E, ID> {

    /**
     * Récupère une entité par son ID.
     *
     * @param id ID de l'entité
     * @return Entité récupérée
     */
    protected abstract E getEntity(ID id);

    /**
     * Met à jour une entité à partir d'une commande.
     *
     * @param entity Entité à mettre à jour
     * @param command Commande de mise à jour
     * @return Entité mise à jour
     */
    protected abstract E updateEntity(E entity, U command);

    /**
     * Convertit une entité de domaine en DTO.
     *
     * @param entity Entité de domaine
     * @return DTO
     */
    protected abstract T toDto(E entity);

    /**
     * Vérifie si l'entité est modifiable.
     *
     * @param entity Entité à vérifier
     * @return true si l'entité est modifiable, false sinon
     */
    protected abstract boolean isEntityModifiable(E entity);

    /**
     * Retourne le nom de l'entité pour les messages d'erreur.
     *
     * @return Nom de l'entité
     */
    protected abstract String getEntityName();

    /**
     * Exécute le cas d'utilisation.
     *
     * @param command Commande de mise à jour
     * @return DTO de l'entité mise à jour
     */
    @Transactional
    public T execute(U command) {
        log.debug("Exécution du cas d'utilisation de mise à jour de {}", getEntityName());

        // Récupération de l'ID à partir de la commande
        ID id = getIdFromCommand(command);

        // Récupération de l'entité
        E entity = getEntity(id);

        // Vérification que l'entité est modifiable
        if (!isEntityModifiable(entity)) {
            throw new BusinessException(
                    getEntityName() + ".readonly",
                    "Ce " + getEntityName() + " ne peut pas être modifié"
            );
        }

        // Mise à jour de l'entité
        E updatedEntity = updateEntity(entity, command);

        // Conversion en DTO
        return toDto(updatedEntity);
    }

    /**
     * Récupère l'ID à partir de la commande.
     * À implémenter dans les classes concrètes.
     *
     * @param command Commande de mise à jour
     * @return ID de l'entité
     */
    protected abstract ID getIdFromCommand(U command);
}
```

### 4. Utilitaires HTTP

```java
package com.devolution.saas.common.util;

import jakarta.servlet.http.HttpServletRequest;
import org.springframework.util.StringUtils;

/**
 * Utilitaires pour les requêtes HTTP.
 */
public class HttpRequestUtils {

    /**
     * Récupère l'adresse IP du client.
     *
     * @param request Requête HTTP
     * @return Adresse IP du client
     */
    public static String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (StringUtils.hasText(xForwardedFor)) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }

    /**
     * Extrait la clé API de la requête HTTP.
     *
     * @param request Requête HTTP
     * @return Clé API ou null
     */
    public static String resolveApiKey(HttpServletRequest request) {
        // Vérification dans l'en-tête X-API-Key
        String apiKey = request.getHeader("X-API-Key");
        if (StringUtils.hasText(apiKey)) {
            return apiKey;
        }

        // Vérification dans le paramètre de requête api_key
        return request.getParameter("api_key");
    }

    /**
     * Extrait le jeton JWT de la requête HTTP.
     *
     * @param request Requête HTTP
     * @return Jeton JWT ou null
     */
    public static String resolveJwtToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### 5. Entités système

```java
package com.devolution.saas.common.domain.model;

import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;

/**
 * Entité qui peut être définie par le système.
 * Étend TenantAwareEntity et ajoute un indicateur pour les entités définies par le système.
 */
@Getter
@Setter
@MappedSuperclass
public abstract class SystemDefinedEntity extends TenantAwareEntity {

    private static final long serialVersionUID = 1L;

    /**
     * Indique si l'entité est définie par le système.
     * Les entités définies par le système ne peuvent généralement pas être modifiées ou supprimées.
     */
    @Column(name = "system_defined", nullable = false)
    private boolean systemDefined = false;
}
```

## Plan d'implémentation

### Phase 1: Préparation (Jour 1)

1. Créer les classes de base dans le package `common`
    - `AbstractCrudController`
    - `AbstractCrudService`
    - `AbstractCreateUseCase` et `AbstractUpdateUseCase`
    - `HttpRequestUtils`
    - `SystemDefinedEntity`

### Phase 2: Refactoring des contrôleurs (Jour 2-3)

1. Refactorer `UserController` pour utiliser `AbstractCrudController`
2. Refactorer `RoleController` pour utiliser `AbstractCrudController`
3. Refactorer `PermissionController` pour utiliser `AbstractCrudController`
4. Refactorer `OrganizationController` pour utiliser `AbstractCrudController`
5. Refactorer `ApiKeyController` pour utiliser `AbstractCrudController`

### Phase 3: Refactoring des services (Jour 4-5)

1. Refactorer `UserService` pour utiliser `AbstractCrudService`
2. Refactorer `RoleService` pour utiliser `AbstractCrudService`
3. Refactorer `PermissionService` pour utiliser `AbstractCrudService`
4. Refactorer `OrganizationService` pour utiliser `AbstractCrudService`
5. Refactorer `ApiKeyService` pour utiliser `AbstractCrudService`

### Phase 4: Refactoring des cas d'utilisation (Jour 6-7)

1. Refactorer les cas d'utilisation de création pour utiliser `AbstractCreateUseCase`
2. Refactorer les cas d'utilisation de mise à jour pour utiliser `AbstractUpdateUseCase`

### Phase 5: Refactoring des filtres et aspects (Jour 8)

1. Refactorer `JwtAuthenticationFilter` pour utiliser `HttpRequestUtils`
2. Refactorer `ApiKeyAuthenticationFilter` pour utiliser `HttpRequestUtils`
3. Refactorer `RateLimitFilter` pour utiliser `HttpRequestUtils`

### Phase 6: Tests et validation (Jour 9-10)

1. Exécuter tous les tests unitaires
2. Exécuter tous les tests d'intégration
3. Vérifier que l'application fonctionne correctement
4. Corriger les éventuels problèmes

## Métriques de succès

1. Réduction du nombre de lignes de code (au moins 20%)
2. Tous les tests passent
3. L'application fonctionne correctement
4. Le code est plus facile à maintenir et à faire évoluer
